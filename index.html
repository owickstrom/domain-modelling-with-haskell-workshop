<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Workshop: Domain Modelling with Haskell</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="workshop/style.css">
  <link rel="stylesheet" href="workshop/iosevka/iosevka.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Workshop: Domain Modelling with Haskell</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#setup">Setup</a><ul>
<li><a href="#installing-stack">Installing Stack</a></li>
<li><a href="#cloning-and-installing-dependencies">Cloning and Installing Dependencies</a></li>
</ul></li>
<li><a href="#how-to-follow-this-tutorial">How to follow this tutorial</a></li>
<li><a href="#part-1-data-structures">Part 1: Data Structures</a><ul>
<li><a href="#project">Project</a></li>
<li><a href="#project-id">Project ID</a></li>
<li><a href="#budget">Budget</a></li>
<li><a href="#transaction">Transaction</a></li>
<li><a href="#money">Money</a></li>
<li><a href="#get-budget-by-project-id">Get Budget by Project ID</a></li>
<li><a href="#get-transactions-by-project-id">Get Transactions by Project ID</a></li>
<li><a href="#report">Report</a></li>
<li><a href="#calculate-report">Calculate Report</a></li>
<li><a href="#calculate-project-report">Calculate Project Report</a></li>
<li><a href="#testing-it-all-out">Testing it all out</a></li>
</ul></li>
<li><a href="#digging-deeper">Digging Deeper</a></li>
</ul>
</nav>
<p>Welcome to the “Domain Modelling with Haskell” workshop, based off the screencast series from <a href="https://haskell-at-work.com">Haskell at Work</a>. This document contains the instructions, exercises, and references for you to get started with Haskell and domain modelling, in the example domain of <em>project management</em>.</p>
<h2 id="introduction">Introduction</h2>
<p>We will model a simple project management system, and implement <em>reporting</em> functionality based on our core data structures. The sections in this workshop explore increasingly abstract techniques for working with Haskell data structures. We begin with regular Haskell data structures, monoids, and explicit recursion.</p>
<h2 id="setup">Setup</h2>
<h3 id="installing-stack">Installing Stack</h3>
<p>If you don’t have any strong preferences on your Haskell installation, and just want to get going, it is recommended to use <a href="https://haskellstack.org">Stack</a> to install the Haskell compiler, the required libraries, and compiling the code. The website has the installation instructions on the home page.</p>
<p>If you do install GHC and Cabal in another way, do consider using Cabal <code>new-build</code>, a sandbox, or some other means of isolating the build.</p>
<h3 id="cloning-and-installing-dependencies">Cloning and Installing Dependencies</h3>
<p>To get you up and running, begin by cloning this repository to your local machine:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="fu">git</span> clone https://github.com/owickstrom/domain-modelling-with-haskell-workshop.git</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">$ <span class="bu">cd</span> domain-modelling-with-haskell-workshop</a></code></pre></div>
<p>Then, install all dependencies required, and build the project:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> build</a></code></pre></div>
<p>The Cabal file for this project has a number of library dependencies already, so that you can have them installed beforehand, and complete the workshop without an (or with a flaky) internet connection.</p>
<p>All right! If all went well, you are ready to get started. You may edit Haskell files in any text editor you like. If you don’t have any strong preference, both <a href="https://code.visualstudio.com/">VS Code</a> and <a href="https://atom.io/">Atom</a> are easy to get started with.</p>
<p>Setting up Haskell tooling is way out of the scope of this workshop, and you will not need anything fancy. We will load and test the code in GHCi (a REPL) anyway.</p>
<h2 id="how-to-follow-this-tutorial">How to follow this tutorial</h2>
<p>When you are done with the setup, begin by running the following command in your terminal. It will start GHCi and load the Project module.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> repl</a></code></pre></div>
<p>Open your text editor and navigate to the workshop Git repository. Write all your code in <code>src/Project.hs</code> under the module header:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Project</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">-- Your stuff here!</span></a></code></pre></div>
<p>When you want to check some code you have written, write <code>:reload</code> and hit Enter. If there are any type errors, GHCi will print them.</p>
<pre class="sourceCode ghci"><code>&gt; :reload
Ok, one module loaded.
Collecting type info for 1 module(s) ...</code></pre>
<h2 id="part-1-data-structures">Part 1: Data Structures</h2>
<p>You will begin by laying the groundwork for the project management system. The concepts and features that we need in the are listed and described informally below.</p>
<p>Go through this list in order and implement each part. The &quot;things&quot; should be modelled as data types, and operations and queries as functions (using <code>IO</code> where needed.) Click the <strong>TIP</strong> boxes to get some assistance if you need.</p>
<h3 id="project">Project</h3>
<p>The core concept in the system is a <em>project</em>. A project can be either a single project or a project group. Both single projects and project groups have <em>names</em>, and single projects also have <em>project IDs</em>, which are natural numbers. A project group has a list of child projects.</p>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>A data structure with multiple variants can be expressed using a data type with multiple <em>constructors:</em></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MyThing</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">RegularThing</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">OtherThing</span> <span class="dt">String</span></a></code></pre></div>
</div>
<h3 id="project-id">Project ID</h3>
<p>A project ID uniqely identifies a <em>single</em> project (non-group project) in the system.</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>Create a type for project IDs to make it more explicit, either using a type alias, or using a newtype.</p>
</div>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>By wrapping in a newtype, instead of using a &quot;raw&quot; numeric type or a type alias, you make it safer to pass around in the code, as it cannot be mistakenly interchanged with other integers.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ProjectId</span> <span class="fu">=</span> <span class="dt">ProjectId</span> {<span class="ot"> unProjectId ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
</div>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>To construct project IDs using numeric literals, you can derive the <code>Num</code> class:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Project</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">ProjectId</span> <span class="fu">=</span> <span class="dt">ProjectId</span> {<span class="ot"> unProjectId ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)</a></code></pre></div>
<p>This enables you to write:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">pId ::</span> <span class="dt">ProjectId</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">pId <span class="fu">=</span> <span class="dv">123</span></a></code></pre></div>
</div>
<h3 id="budget">Budget</h3>
<p>A budget describes the expected <em>income</em> and <em>expenditure</em> for a project, both being monetary values.</p>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>A Haskell data type with multiple fields can be expressed using record syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Budget</span> <span class="fu">=</span> <span class="dt">Budget</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  {<span class="ot"> budgetIncome ::</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  ,<span class="ot"> budgetExpenditure ::</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
</div>
<h3 id="transaction">Transaction</h3>
<p>A transaction is a very simplified concept describing a <em>sale</em> or a <em>purchase</em>. Each type of transaction has an amount (a monetary value.)</p>
<h3 id="money">Money</h3>
<p>A representation of monetary values.</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>Represent <code>Money</code> using the <code>Decimal</code> type from the <a href="https://hackage.haskell.org/package/Decimal-0.5.1/docs/Data-Decimal.html">Decimal</a> package.</p>
</div>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>Create a <code>newtype</code> for monetary values by wrapping the <code>Decimal</code> type (from the <em>Decimal</em> library):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Project</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.Decimal</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Money</span> <span class="fu">=</span> <span class="dt">Money</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  {<span class="ot"> unMoney ::</span> <span class="dt">Decimal</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Num</span>)</a></code></pre></div>
</div>
<h3 id="get-budget-by-project-id">Get Budget by Project ID</h3>
<p>Given a project ID, we need to be able to retrieve a budget for the corresponding project.</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>To save time, hard-code or generate a random result, instead of using a real persistent database. The function should still return <code>IO</code>, e.g:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">getBudget ::</span> <span class="dt">ProjectId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Budget</span></a></code></pre></div>
</div>
<h3 id="get-transactions-by-project-id">Get Transactions by Project ID</h3>
<p>Given a project ID, we need to be able to retrieve a list of transactions for the corresponding project.</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>To save time, hard-code or generate a random result, instead of using a real persistent database or querying an external system. The function should still return <code>IO</code>, e.g:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">getTransactions ::</span> <span class="dt">ProjectId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Transaction</span>]</a></code></pre></div>
</div>
<h3 id="report">Report</h3>
<p>A report represents the result of the <em>report calculation</em>. It has a <em>budget profit</em>, a <em>net profit</em>, and a <em>difference</em>, all being monetary values.</p>
<h3 id="calculate-report">Calculate Report</h3>
<p>The reporting calculation, depending on a project budget and a list of project transactions. It calculates a <a href="#report">Report</a>, where:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">budget profit</mtext><mo>=</mo><mtext mathvariant="normal">income</mtext><mo>−</mo><mtext mathvariant="normal">expenditure</mtext></mrow><annotation encoding="application/x-tex">\text{budget profit} = \text{income} - \text{expenditure}</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">net profit</mtext><mo>=</mo><mtext mathvariant="normal">sales</mtext><mo>−</mo><mtext mathvariant="normal">purchases</mtext></mrow><annotation encoding="application/x-tex">\text{net profit} = \text{sales} - \text{purchases}</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">difference</mtext><mo>=</mo><mtext mathvariant="normal">net profit</mtext><mo>−</mo><mtext mathvariant="normal">budget profit</mtext></mrow><annotation encoding="application/x-tex">\text{difference} = \text{net profit} - \text{budget profit}</annotation></semantics></math></p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>The report calculation function should be a pure function, with a Haskell type signature like:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">calculateReport ::</span> <span class="dt">Budget</span> <span class="ot">-&gt;</span> [<span class="dt">Transaction</span>] <span class="ot">-&gt;</span> <span class="dt">Report</span></a></code></pre></div>
</div>
<h3 id="calculate-project-report">Calculate Project Report</h3>
<p>Given a project, this function calculates a single aggregated <a href="#report">Report</a> for the entire project hierarchy. It needs to recursively walk the projects, query their budgets and transactions, calculate reports, and combine those reports into one.</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>The project report calculation function return <code>IO Report</code>, e.g.:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">calculateProjectReport ::</span> <span class="dt">Project</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Report</span></a></code></pre></div>
<p>Use the (fake) queries you wrote earlier to obtain a budget and a list of transactions for each project.</p>
</div>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>Create an instance of <code>Monoid</code> for <code>Report</code> and use it to combine reports:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Report</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Report</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  mappend (<span class="dt">Report</span> b1 n1 d1) (<span class="dt">Report</span> b2 n2 d2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    <span class="dt">Report</span> (b1 <span class="fu">+</span> b2) (n1 <span class="fu">+</span> n2) (d1 <span class="fu">+</span> d2)</a></code></pre></div>
<p>Now you can combine a list of reports using <code>fold</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">megaReport ::</span> <span class="dt">Report</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">megaReport <span class="fu">=</span> fold [report1, report2, report3]</a></code></pre></div>
</div>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>Recurse through the project hierarchy using by pattern matching on the constructors,</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">calculateProjectReport ::</span> <span class="dt">Project</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Report</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">calculateProjectReport (<span class="dt">SingleProject</span> projectId _) <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">calculateProjectReport (<span class="dt">ProjectGroup</span> _ projects) <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>and by folding the result of recursively applying <code>calculateProjectReport</code> on project group children:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">foldMap calculateProjectReport <span class="fu">&lt;</span>child projects<span class="fu">&gt;</span></a></code></pre></div>
</div>
<h3 id="testing-it-all-out">Testing it all out</h3>
<p>Whew! Those are all the things needed in the project management system. To have some data to try report calculation on, create a <code>someProject</code> definition of type <code>Project</code>. You may construct this value however you like, but make sure to have at least three levels of project groups.</p>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>As an example of a project value, the following represents a Swedish project hierarchy of some sort.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">someProject ::</span> <span class="dt">Project</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">someProject <span class="fu">=</span> <span class="dt">ProjectGroup</span> <span class="st">&quot;Sweden&quot;</span> [stockholm, gothenburg, malmo]</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    stockholm <span class="fu">=</span> <span class="dt">Project</span> <span class="dv">1</span> <span class="st">&quot;Stockholm&quot;</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    gothenburg <span class="fu">=</span> <span class="dt">Project</span> <span class="dv">2</span> <span class="st">&quot;Gothenburg&quot;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    malmo <span class="fu">=</span> <span class="dt">ProjectGroup</span> <span class="st">&quot;malmo&quot;</span> [city, limhamn]</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    city <span class="fu">=</span> <span class="dt">Project</span> <span class="dv">3</span> <span class="st">&quot;malmo City&quot;</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    limhamn <span class="fu">=</span> <span class="dt">Project</span> <span class="dv">4</span> <span class="st">&quot;Limhamn&quot;</span></a></code></pre></div>
</div>
<p>Now, apply the report calculation function to the demo project. Do you get a single report back?</p>
<div class="tip">
<div class="admonition-title">
<p>Tip</p>
</div>
<p>To calculate a report in the GHCi REPL, run something like the following, and you should see the report data structure printed.</p>
<pre class="sourceCode ghci"><code>&gt; :reload
&gt; calculateProjectReport someProject
Report {budgetProfit = Money {unMoney = -5392.74046336179},
netProfit = Money {unMoney = 2191.2802854168813}, difference =
Money {unMoney = 7584.020748778671}}</code></pre>
</div>
<p>Congratulations! You have completed the first part of &quot;Domain Modelling with Haskell.&quot;</p>
<h2 id="digging-deeper">Digging Deeper</h2>
<p>This workshop is based on the video series from Haskell at Work, including four videos corresponding to the parts in the workshop:</p>
<ol type="1">
<li><a href="https://haskell-at-work.com/episodes/2018-01-19-domain-modelling-with-haskell-data-structures.html">Data Structures</a></li>
<li><a href="https://haskell-at-work.com/episodes/2018-01-22-domain-modelling-with-haskell-generalizing-with-foldable-and-traversable.html">Generalizing with Foldable and Traversable</a></li>
<li><a href="https://haskell-at-work.com/episodes/2018-02-02-domain-modelling-with-haskell-accumulating-with-writert.html">Accumulating with WriterT</a></li>
<li><a href="https://haskell-at-work.com/episodes/2018-02-11-domain-modelling-with-haskell-factoring-out-recursion.html">Factoring Out Recursion</a></li>
</ol>
<p>If you want to explore further, I can recommend checking out those videos and the show notes. Also, the full source code for the videos is available at <a href="https://github.com/haskell-at-work/domain-modelling-with-haskell" class="uri">https://github.com/haskell-at-work/domain-modelling-with-haskell</a>.</p>
<script>
document.querySelectorAll('.tip').forEach(function (tip) {
  tip.addEventListener('click', function () {
    console.log('hello');
    tip.classList.toggle('visible');
  });
});
</script>
<footer>
    Copyright &copy; 2018 Oskar Wickström
</footer>
</body>
</html>
